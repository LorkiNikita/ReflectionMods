# СНСР v0.3-Стандарт Написания Скриптов Рефлекшн v0.3

## Общие-правила:

1. Писать понятный и читаемый код (т.е соблюдать правила изложенные по сиснтаксису ниже)
2. Писать оптимизированный код,т.е применять как можно меньше действий и потреблять как можно меньше памяти (приоритет: скорость)
3. Описывать действия внутри кода понятными и читаемыми комментариями на русском,но не запрещено описывать дополнительно на других языках
4. Придерживатся общего блока(вид блока на сервере дискорд) стандарта 
5. Любой скрипт не должен критически зависеть от скрипта другой сборки
6. Запрещено использовать dll-библиотеки сторонних модов без общего согласия скриптоделов
7. Скрипты не должны критически зависеть от новой игры, кроме некоторых случаев
8. Скрипты должны быть полностью OpenSource после окончания их разработки (касается только rson,svr и также не касается "особых" случаев)
9. После составления скрипта он должен быть кратко расписан в чате разработки скриптов
10. Скрипты должны сохранятся в двух вариациях svr и rson
11. Код должен отвечать стандартам ООП которые реализованы через сущности

### Внешний-Вид

#### Отступы и переносы строк:

1. Нужно использовать отступы перед и после операторов 

Пример:

```python
a = 10
```

2. Комментарии должны всегда иметь перенос строки(так как к сожалению в текущий рскрипт такого не завезли)

### Правила именования

#### Абстрактный код

1. Любая сущность ООП должна именоватся с большой буквы 

###### Примеры

```c++  
struct THull
```

```c++
class THull
```
```php  
interface THull
```


###### Примеры-кастомных типов

```c++
custype htype 8 Тестовый тип

custype strUTF persymb:16 Тестовый тип 2
```



#### Реальный код

##### Переменная должна быть именованована с маленькой буквы(не касается массива объектов класса,и массивов хранящих структуры)

###### Примеры

```php
int checker
dword id
str tstr
array skills
```
НО:

```php
array OClassName
```

Потому что хранит свойства класса

##### Функции должны именоватся с большой буквы

###### Примеры

```php
function PirateRemove (...) {...}
function Ship (...) {...}
function AssCMP (...) {...}
```

##### Комментарии

В самом начале инит кода вы должны описать версию СНСР 

###### Синтаксис:

```php
//СНСР v0.3
```

## Абстракции:

Абстрактные сущности, типы и многое другое (пока что описываются в комментариях и являются абстрацией,по мере написания своего рскрипт сущности будут внедрены в компиляцию):

### Свойтва И Методы

##### Синтаксис

###### Описания свойства

```[модификатор доступа] [тип] [имясвойства]```

###### Описание метода

```[модификатор доступа] [тип того что метод возвращает,если void то ничего] [имяметода] [аргументы]```

-Побробнее о том как и когда описывать свойства и методы в сущностях которые их применяют

###### Модификаторы-Доступа

- public

- private
- Подробнее о применении в самих сущностях



###### В сущности trait

-Все методы тут являются публичными(public), но для их использования нужно прописать use в других сущностях(подробнее в инфо по трейтах)

###### В сущности absclass

public - может применятся где угодно 
private - может применятся только в классе, т.е переменную больше нельзя нигде использовать

###### В блоке кода

public - может применятся где угодно
private - может применятся только внутри блока кода

## Абстрактные-Типы

##### Основные-Типы-Для-Применения-В-Сущностях

- **int** - числовой тип(16 бит)
- **dword** - числовой тип для чисел больше 0
- **string** - строковый тип
- **float** - дробный тип
- **bool** - числовой тип
- **array** - дабомассив
- **any** - Любой тип

##### Будущие типы RefUtilities(создание переменных через dll в разработке):

- ```python
  str - строковое значение (2 байта Windows и 4 байта Linux на СИМВОЛ),в игру возвращаем string, из С++ обычный str (Unicode) (всё что угодно но занимает целых 2 байта)
  astr - строковое значение (1 байт на символ),в игру возвращаем string, из С++ обычный str (ANSI) (только саксонский)
  rustr - строковое значение (1 байт на символ), (СССКС-USSES) (вся киррилица + неполный саксонский),в игру передаётся обычная unicode строка
  ```

- ```c++
  int8 - числовое(+отрицательное) значение(8 бит = от -128 до 127),в игру передаётся,в игру передаётся обычный int
  int16 - числовое(+отрицательное) значение(16 бит = от -32768 до 32767),в игру передаётся,в игру передаётся обычный int
  int32  - числовое(+отрицательное) значение(32 бита = от -2147483648 до 2147483647),в игру передаётся обычный int
  ```

- ```c++
  dword8 - числовое значение(8 бит = от 0 до 255),в игру передаётся обычный int
  dword16 - числовое значение(16 бит = от 0 до 65535),в игру передаётся обычный int
  dword32 - числовое значение(32 бита = от  0 до 4294967295),в игру передаётся обычный int
  ```

- ```python
  bool - логическое значение (8 бит)
  float - дробное значение,по факту записываем также во float,хотя в игре это типо double
  any - любое значение
  ```

  



##### Основные-Типы-Для-Применения-В-Сущности-Структуры-Байтов

```
VMT - указатель на таблицу методов(8 бит)
```

```js
gap8 - неизвестный байт(8 бит)
gap16 - два неизвестных байта (16 бит)
gap32 - четыре неизвестных байта (32 бит)
```

```c++
int - числовой тип(32 бит)
int8 - числовое(+отрицательное) значение(8 бит = от -128 до 127),в игру передаётся,в игру передаётся обычный int
int16 - числовое(+отрицательное) значение(16 бит = от -32768 до 32767),в игру передаётся,в игру передаётся обычный int
int32  - числовое(+отрицательное) значение(32 бита = от -2147483648 до 2147483647),в игру передаётся обычный int
```

```c++
dword - числовой тип для чисел больше 0(32 бит)
dword8 - числовое значение(8 бит = от 0 до 255),в игру передаётся обычный int
dword16 - числовое значение(16 бит = от 0 до 65535),в игру передаётся обычный int
dword32 - числовое значение(32 бита = от  0 до 4294967295),в игру передаётся обычный int
```

```python
float - дробное значение,по факту записываем также во float,хотя в игре это типо double
double - дробное значение 32 бита
```

```python
string - строковый тип (2 байта Windows и 4 байта Linux на СИМВОЛ)
str - строковое значение (2 байта Windows и 4 байта Linux на СИМВОЛ),в игру возвращаем string, из С++ обычный str (Unicode) (всё что угодно но занимает целых 2 байта)
astr - строковое значение (1 байт на символ),в игру возвращаем string, из С++ обычный str (ANSI) (только саксонский)
```

```python
bool - логическое значение (8 бит)
```

```c++
any - Любой тип
```

##### Прочие-Типы

```
void - чисто для методов,обозначает что ничего метод ничего не возвращает
```

```c++
pair_float = хранит в себе два float x и y
Структура:
//struct pair_float
//float:x
//float:y
```

```c++
pair_double = хранит в себе два double(32 бита) x и y
Структура:
//struct pair_float
//double:x
//double:y
```

Также можно применить импорт абстрактного модуля types:

```python
//import sptypes from types
```



```js
const - переменная которую нельзя переопределять
temp - временная переменная которая каждый ход очищается
```



```python
//import itertypes from types
```



```
iterator - элемент который постоянно меняет значение в цикле
terniterator - элемент который постоянно меняет значение в цикле и не обнуляестя каждый ход
```



```python
//import ptrtypes from types
```



```
itemptr - указатель на предемет
shipptr - указатель на корабль
planetptr - указатель на планету
sectorptr - указатель на сектор
starptr - указатель на звезду
unknownptr - указатель неизвестно на что
```

##### Объявление-Кастомных-Типов

###### Синтаксис

```c++
//custype [имятипа] [размервбитах] [описание_типа]
```

###### Размер в битах

```c++
-unlimited - неограниченный размер 
-persymb:8 - в основном для строковых типов,будет означать что на символ выделяется 8 бит
```



###### Кастомные типы объявляются вначале главного инит кода

Небольшой совет:
-Типами можно иметь любые переменнные скрипта вначале глобал блока кода, но нужно понимать что потом они могут быть переназначены снова в сущностях ООП или в других блоках кода внутри

## Абстрактные Сущности

### СУЩНОСТЬ-БЛОКА-КОДА

#### Для чего и где применять?

Применяется для обозначения какого блока кода в блок где можно описывать что этот блок и как применяет

##### Синтаксис

```c++
//block [имя_блока]
//[proparties]
...
//blockend
```

##### Важные особенности:

-ВАЖНО: весь код который не в блоках кода,называется глобал блоком кода

-Блок кода(не глобальный) не может содержать внутри сущности ООП(кроме структур)

-Диалоги также являются блоком кода

###### Методы,свойства и модификаторы доступа:

-Методы и свойства в блоке кода просто расписывают возможность применения в других блоках кода и в общем коде(при желании их можно и не расписывать,но тогда всё будет по умолчанию публичным)

-Название абстрактной переменной должно соответствовать реальной переменной для которого описывается

```c++
-public - может применятся где угодно
-private - может применятся только в самом блоке кода и в блоках кода которые внутри(при их наличии)
```

###### Небольшой совет

-Имеет смысл приватные свойства именовать по названию блока
-Для более удобного применения советую ставить комментарий что делает данный блок, перед самим блоком для дальнейшего понимания

###### Примеры

```c++
--- Пример 1 
//block
//public int integer 
//private str string
...
//blockend


//block
//public int integer 
//Но private str string мы уже использовать не можем
...
//blockend
```




```c++
--- Пример 2 с вложеными блоками блоками

//block
//public int integer 
//private str string
...
//block
//public int integer 
//Но private str string мы тоже уже использовать не можем
...
//blockend
//blockend
```







### СУЩНОСТИ ООП

#### Сущность class

##### Для чего и где применять?

-Применяется для создания каких-то либо абстрактных объектов, которые обязательно имеют такие же аналоги в реальном коде

##### Синтаксис

```python
//class [имя_класса]
//[proparties]
//[constructor]
//[methods]
//[destructor]
```

##### Важные особенности

-В классе реальный код должен быть только в методах
-Класс не должен быть(т.е не иметь методов и свойств)

##### Методы,свойства и модификаторы доступа

###### Для свойств

```cpp
-public - применяется только в будущих экземплярах объекта или внутри самого класса
-private- свойство может применятся только в классе или другими методами класса после создания экземпляра,и также не может применятся при наследовании
```

-Также если свойства класса могут использовать, например только один модификатор доступа, можно также вместо описания каждого свойства описать вот так:

```cpp
//public *
или
//private *
```

в зависимости от самого модификатора доступа

-И также если меньше 1/3 свойств использует другие модификаторы доступа,можно так же сначало описать что применяет другие модификаторы доступа а потом то что показано выше
Пример:

```cpp
//private int starid 
//private int sectorid 
//public *
```

-Свойства нужно сохранять с каждым объектом,для того чтоб узнать как это сделать в реальном коде смотрите раздел "Связь с реальным кодом" ниже

###### Для методов

```cpp
-public - применяется только в будущих экземплярах объекта или внутри самого класса
-private - метод может применятся только в классе или другими методами класса после создания экземпляра,и также не может применятся при наследовании
```



##### Конструкторы и деструкторы:

- -Конструкторы нужно в основном для инициализации свойств объектов или предвызов каких-то методов
- -Деструкторы грубо говоря обратное для конструкторов,но можно конечно делать вызовы каких-нибудь других методов или функций

- -В конструкторе если есть свойсва в реальном коде их нужно обязательно занулить или занести нужное значение, в деструкторе нужно ОБЯЗАТЕЛЬНО сделать обратно(т.е почистить часть этого массива по индексу в листе объектов класса с помощью ArrayClear())(ИНАЧЕ БУДЕТ УТЕЧКА ПАМЯТИ)

###### Создание экземпляров

- -Для создания экземпляров класса нужно использовать ключевое слово new,и если класс имеет конструктор то вызвать конструктор в реальном коде

###### Наследование

- -Наследование грубо говоря это создание класса на основе другого класса с сохранением всех методов и свой
- -Конструкторы не наследуются при наследовании,также как и деструкторы

###### Связь с реальным кодом

- -Как вы могли ранее прочитать, если вы хотите сохранять переменные как свойства в объекте, вам требуется описать абстракцию вида(расписана выше) и реальный код расписан тут примерами

- -Нужно обязательно приписать всем методам имя класса перед именем метода

- -В недалёком будущем планируется улучшить связь с реальным кодом добавлением функций работы с свойствами CreateProp SetProp GetProp
  -А в более далёком будущем планируется написать свой рскрипт с добавлением сущностей в синтаксис
- --Модификаторы доступа(как и для методов так и для свойств) в данной версии стандарта,dll,рскрипта в реальном коде являются по сути просто соглашением

###### Сохранение свойств в объект(сохранение переменных в объект):

- -Свойства в реальном коде должны быть реализованы как массив (подробнее о строении в структуре ниже), так как экземпляров класса может быть несколько,и применятся тоже как массив,поэтому, нужно обязательно описать массив O[имя_класса] (O - сокращение от Objects)

- -Также при применении таких свойств нужно обязательно описать конструктор и в нём предварительно описать ВСЕ свойства

```cpp
Структура массивов OP[имя_класса] описывать не трубуется  
//struct OClassNameObjectProps
//str:propsname:xn -> any:content

//struct OClassName
//int:index:xn -> OClassNameObjectProps:content
```



###### Методы в объектах

-Методы в созданных объектах в реали НЕ сохраняются,их можно просто вызывать
-Так же если в методах есть вдруг применение свойств самого объекта,так как методы в классе не сохраняются, нам нужно в методе принимать аргумент индекса ведущий на свойства объекта класса

###### Наследование 

-При наследовании в реальном коде по надо описывать все свойства которые получились к наследованию,т.е из класса родителя можно брать только те свойства и методы которые надо
-При наследовании можно вызывать только методы класса от которого наследование,и только те методы которые не принимают свойств родительского класса(если это так то можно переописать этот метод)

###### Примеры



###### Пример 1 с публичными свойствами


```cpp
Заранее объявили массив OEngine,и также нам понадобится временный массив tarr

//class Engine

//public int gtl
//public int type
//public str name
//public int speed
//public int8 jump
//public int size

//constructor
function EngineConstructor(int gtl,int type,str name,int size) {
	ArrayAdd(OEngine,oEngine[ArrayDim(OEngine)-1]);
	//tarr - временный массив gtl наше значение 'gtl' имя переменной(должно соответствовать имени в абстракции свойства)
	ArrayAdd(tarr,gtl,'gtl');
	ArrayAdd(tarr,type,'type');
	ArrayAdd(tarr,name,'name');
	ArrayAdd(tarr,0,'speed');
	ArrayAdd(tarr,0,'jump');
	ArrayAdd(tarr,size,'size');
	copy(OEngine[ArrayDim(OEngine)-1],tarr);
	ArrayClear(tarr);
	//Не забываем вернуть индекс под которым данные объекта
	return ArrayDim(OEngine)-1;
}
//public void Test(int arg0)
function Test(int arg0) {

}
...
//new Engine
index = EngineConstructor(7,3,'Name',11)
```

###### Пример 2 c приватными и публичными свойствами

```cpp
Заранее объявили массив OEngine,и также нам понадобится временный массив tarr




//class Engine

//public int gtl
//private int type
//public str name
//public int speed
//public int8 jump
//public int size

//constructor
function EngineConstructor(int gtl,int type,str name,int size) {
	ArrayAdd(OEngine,oEngine[ArrayDim(OEngine)-1]);
	ArrayAdd(tarr,gtl,'gtl');
	ArrayAdd(tarr,type,'type');
	ArrayAdd(tarr,name,'name');
	ArrayAdd(tarr,0,'speed');
	ArrayAdd(tarr,0,'jump');
	ArrayAdd(tarr,size,'size');
	copy(OEngine[ArrayDim(OEngine)-1],tarr);
	ArrayClear(tarr);
	return ArrayDim(OEngine)-1;
}

//public int 
function EngineTypeChecker(int index) {
	int varname = OEngine[index][type];
	...
}

//new Engine
index = EngineConstructor(7,3,'Name',11)
//Так делать нельзя,т.к свойство приватное:
OEngine[index][type]
//А вот так уже можно спокойно,т.к свойство получается вызывается внутри метода класса:
EngineTypeChecker(index);
//С методами всё примерно также,т.е публичные методы можно и так вызывать а приватные только из других методов
```

###### Пример 3 без свойств

```cpp
//class Generator

Можем описать конструктор и в нём вызвать пару методов но тут в нём нет особого смысла,также как и в обратном случае без конструктора нельзя создавать другие методы
//public int GenerateRandom 
function GenerateRandom(dword seed) {
{
function GeneratorConstructor(dword s) {
	
}
//new Generator
GeneratorConstructor(7);
```

###### Пример 4 c наследованием

```cpp
//class Item

//public int gtl
//private int type
//public str name
//public int size

//constructor
function ItemConstructor(int gtl,int type,str name,int size) {
	ArrayAdd(OEngine,oEngine[ArrayDim(OEngine)-1]);
	ArrayAdd(tarr,gtl,'gtl');
	ArrayAdd(tarr,type,'type');
	ArrayAdd(tarr,name,'name');
	ArrayAdd(tarr,size,'size');
	copy(OEngine[ArrayDim(OEngine)-1],tarr);
	ArrayClear(tarr);
	return ArrayDim(OEngine)-1;
}
//public int ItemSize(...)
function ItemSize(index){
	//Также тут я якобы идёт обращение к свойству OEngine[index][type] 
	...
}
//private int ItemPrivateSize(...)
function ItemPrivateSize(...){
	...
}


//class Engine extends Item 

//В абстрактом коде пишем только новые свойства
//public int speed
//public int8 jump

//constructor
function EngineConstructor(int gtl,int type,str name,int size) {
	//Как можно видеть в конструкторе снова инициализируются все свойства,так как у каждого класса один отдельный конструктор
	ArrayAdd(OEngine,oEngine[ArrayDim(OEngine)-1]);
	ArrayAdd(tarr,gtl,'gtl');
	//type мы добавить не можем так как свойство приватное:
	ArrayAdd(tarr,type,'type');
	ArrayAdd(tarr,name,'name');
	ArrayAdd(tarr,0,'speed');
	ArrayAdd(tarr,0,'jump');
	ArrayAdd(tarr,size,'size');
	copy(OEngine[ArrayDim(OEngine)-1],tarr);
	ArrayClear(tarr);
	return ArrayDim(OEngine)-1;
}

//Так как родительский класс в методе ItemSize обращается к свойствам объектов класса то выходит нам надо его пересоздать либо немного переделать прошлый метод(принимать значение а не индекс в массиве ведущий на объект)
//public int EngineSize(...)
function EngineSize(...){	
	...
}
//Но унаследовать вот этот метод мы уже не можем, потому-что модификатор доступа:
//public int EngineSizePrivate(...)
function EngineSizePrivate(...){
	...
}
```



#### Сущность absclass

##### Для чего и где применять?

-Применяется в основном для наследования от него

##### Важные особенности:

-Тот же класс что и изложен выше, НО не может иметь экземпляров и применяется только для наследования обычными классами,т.е нет смысла создавать absclass если нет другого класса который будет его наследовать

##### Синтаксис

```cpp
//absclass [имя_абскласса]
```



#### Сущность interface

##### Для чего и где применять?

Описывает какую-то абстракцию по которой должен имплементироватся будущий class или absclass или несколько таковых

##### Синтаксис

```c++
//[untyped, typed] interface [имя_интерфейса]
```

##### Важные особенности:

```
-untyped - имплементируемый класс может иметь дополнительно и другие методы и свойства нежели в интерфейсе, но он должен содержать методы и свойства интерфейса
-typed  -имплементируемый класс должен только ТЕ методы и свойства которые есть в интерфейсе
-По желанию можно описывать конструктор или деструктор, они не учитываются в типизации
```



###### Методы,свойства и модификаторы доступа

```
-Методы и свойства тут строятся так же как и в class или absclass но тут они не имеют реального кода вообще,просто описание структуры класса
-Так как от структуры могут имплементироватся несколько классов,не обязательно описывать перед методами имя класса
```



##### Примеры

###### Пример 1 untyped

```python
//untyped interface Deand
//constructor
//public dword id
//void InventEquip (int pointer_in_array,int type)
//void InventSkills (int pointer_in_array,int type)
//int GetType ()



//class Deand implements Deand
//constructor
//public dword id
...
//void InventEquip (int pointer_in_array,int type)
...
//void InventSkills (int pointer_in_array,int type)
...
//int GetType ()
...
//int CheckType ()
```



###### Пример 2 typed

```python
Возьмём всё тот же пример 

//untyped interface Deand
//constructor
//public dword id
//void InventEquip (int pointer_in_array,int type)
//void InventSkills (int pointer_in_array,int type)
//int GetType ()



//class Deand implements Deand
//constructor
//public dword id
...
//void InventEquip (int pointer_in_array,int type)
...
//void InventSkills (int pointer_in_array,int type)
...
//int GetType ()
...
//А тут вот этот метод CheckType добавлять уже нельзя, так как класс имплементирован по интерфейсу строгого типа
//int CheckType ()
```



#### Сущность trait

##### Для чего и где применять?

Может хранить абстракцию на какие либо методы которые можно использовать только use только в class,classp или блоках кода

##### Синтаксис

```php
trait [имя_трейта]
```

##### Важные особенности

-Все методы тут являются публичными(так что модификатор доступа не обязателен) но чтоб их применять вам их применять вам нужно в абстрактном коде описать то что вы этот класс используете
-Обратите внимание можно создавать void методы, но в этом нет особого смылса кроме отдельно взятых случаев

##### Примеры

###### Пример 1 с использованием в классе

```ruby
//trait Hash
//int8 CheckHash(str: hash) 
function CheckHash(string hash){
	...
	return ...
}
//str GenerateHash(str strin)
function GenerateHash(string strin){
	...
	return ...
}
//void Test(str string)
function Test(string shash){
	...
}

//class Engine
//use Hash
//И после этого спокойно используйте методы в классе(функции в реальном коде)

//public int gtl
//public int type
//public str name
//public int speed
//public int8 jump
//public int size

//constructor
function EngineConstructor(gtl,type,name,size) {
	ArrayAdd(OEngine,oEngine[ArrayDim(OEngine)-1]);
	//tarr - временный массив gtl наше значение 'gtl' имя переменной(должно соответствовать имени в абстракции свойства)
	ArrayAdd(tarr,gtl,'gtl');
	ArrayAdd(tarr,type,'type');
	//Применение трейта
	ArrayAdd(tarr,GenerateHash(name),'name');
	ArrayAdd(tarr,0,'speed');
	ArrayAdd(tarr,0,'jump');
	ArrayAdd(tarr,size,'size');
	copy(OEngine[ArrayDim(OEngine)-1],tarr);
	ArrayClear(tarr);
	//Не забываем вернуть индекс под которым данные объекта
	return ArrayDim(OEngine)-1;
}

//Дальше идёт создание экземпляра класса,тут это не расписывается(подробнее смотрите в сущности класса)
```



###### Пример 2 с использованием в блоке кода

```ruby
//trait Race
//int StrRaceToNumber(str: race) 
function StrRaceToNumber(string race){
	...
	return ...
}
//str RaceConvertor(str strin)
function RaceConvertor(string strin){
	...
	return ...
}
//block
//use Race
...
И тут можно спокойно применять методы(функции в реальном коде)
//blockend
```



### Сущность struct

##### Для чего и где применять?

Описывает абстракцию значений над какой-то либо структурой данных(массивы,списки,словари,строки,байты)

##### Синтаксис:

```ruby
//[опционально:тип_структуры] struct [имя_структуры] [опционально_указание_реальной_переменной]
```



##### Важные особенности

:xn - обозначает неизвестное колво
:x[n] :x10 :x25 - где n обозначает колво

-Зарезервированые имена после типа:
index(int) - обозначает то что это индекс в массиве или списке
indexfp[разделитель](int) - обозначает что значение берётся по разделителям (для строк)

content(all) - служит указанием для того что свойство в структуре содержит какой-то контент

-Структура может применятся в качестве типа

-Структура также может использовать другие структуры в качестве типа



##### Структурные типы

```
обычно - структура словаря(ассоциативного массива)
str - структура строки разделйнной разделителями внутри обязательно должно быть indexfp
list - структура подобия списка(массива),в ней можно не описывать что является индексом так как их тут нет
byte - байтовая структура,и тут тоже не надо описывать что является индексом,и так понятно что читаем с байт
```

-Также можно применять после типа разименование(*),это будет означать что на этом месте в структуре хранится указатель на структуру

-Вместо : можно использовать пробел

##### Примеры

###### Пример 1

//struct ShopList
//int:index -> str:nameshop

Будет хранить абстракцию для 
[0=>'Магазин Имя']

###### Пример 2

```python
//struct ShopList
//int:index:x10 -> str:nameshop

Будет хранить абстракцию для диапазона значений
от [0=>'Магазин Имя'] 
до [9=>'Магазин Имя']
```



###### Пример 3 со строками

```python
//str struct String
//int:indexfp[,]:xn -> str:name,str:subname

Будет хранить абстракцию для диапазона значений 
от [0,'ЛюбоеИмя,ЛюбаяФамилия']
до [?,'ЛюбоеИмя,ЛюбаяФамилия']
```



###### Пример 4 с использованием структур как тип в других структурах

```python
//str struct ShopItems
//int:index:xn -> int:iditem str:nameitem int:broken int:stats

//struct Shop
//int:itemscou -> int:content
//int:shopid -> str:content
//int:nameshop -> str:content
//int:itemscou -> int:content
//int:items -> ShopItems:content
```



###### Пример 5  описания структуры списка:

```python
//struct Ship
//str:name
//str:fullname
//pair_float:coords
//int:hp
```



###### Пример 6 описания байтовой структуры

```c++
struct TAsteroid {
    VMT cls;

int index;
TStar* star;
pair_float pos;
pair_float unk;
pair_float speed;
UNK _24;
UNK _28;
UNK _2C;
int minerals;
TObjectSE* graph;
UNK _38;

};
-C++ структура TAsteroid.Автор denball
```

```python
//byte struct TAsteroid
//VMT:cls

//int:index
//starptr:star
//pair_float:pos
//pair_float:unk
//pair_float:speed
//dword _24
//dword _28
//dword _2С
//int minerals
//unknownptr graph
//dword _38
```



###### Пример 7 с разименованием

```
//byte struct TAsteroid
//VMT:cls

//int:index
//TStar* star
//pair_float:pos
//pair_float:unk
//pair_float:speed
//dword _24
//dword _28
//dword _2С
//int minerals
//TObjectSE* graph
//dword _38

-Но не забудьте перед этим описать структуры TStar и TObjectSE
-Также вы можете в реальном коде обозначить что массив хранит какуе-то структуры(описывать вначале любого блока кода)
//array arr int:index -> ShopItem:content

-Или сам является структурой
//ShopItem arr
```



### СУЩНОСТИ-МОДУЛИРОВАНИЯ

#### Сущность import

##### Для чего и где применять?

Применяется для того чтоб обозначить использование кода из других модов.

##### Важные особенности:

-Если мод не из какой-то сборки можно просто писать //import [имя_мода] from OtherMods

##### Синтаксис:

```python
//import [имя_мода] from [имя_сборки]
или полный импорт
//import [имя_сборки] 
```



#### Сущность dllimport

##### Для чего и где применять?

Применяется для того чтоб обозначить использование каких либо DLL библиотек из других модов.-*--Важные особенности:
-Если мод не из какой-то сборки можно просто писать //dllimport [имя_мода_в_котором_длл] from OtherMods

Синтаксис:

```python
//dllimport [имямодавкоторомдлл] from [имясборки]
или полный импорт
//dllimport [имясборки] 
```



### Для чего вообще эти сущности?

Если коротко нужны они для более быстрого проектирования и написания кода.Рассмотрим пример с модом RefSpAgentDefense

Без сущностей у нас получится гора функций которые довольно сложно сортировать
например у нас будут как попало сложены функции спавна SpawnPirate,PirateInvent,SpawnAgent,AgentInvent,WarriorSpawn,WarriorInvent
и не понятно как и для чего они будут нужны

вместо этого мы можем создать  

```c++
//import types

int i;
//interface Ship
//Метод инвентаризации корабля
//private void Invent (shipptr:ship)



//class Pirate impl Ship:
//constructor
function PirateConstructor(){

}

//private void Invent (shipptr:ship)
function PirateInvent(dword ship){
}



//class Agent impl Ship:
//constructor
function AgentConstructor(){
}

//private void Invent (shipptr:ship)
function PirateInvent(dword ship){
}



//class Warrior impl Ship:
//constructor
function WarriorConstructor(){
}

//private void Invent (shipptr:ship)
function PirateInvent(dword ship){
}
```

в терн коде 

```c++
for(i = 0;i<=6;i = i+1){
	//new Pirate
	PirateConstructor()
}
```

и это только малая часть того что можно использовать



## Прочее

###### Автор:Lorki

###### Поддержка от Reflection Team

#### Контакты-Reflection-Team

##### Наш сайт: https://reflection.ga

###### По любым вопросам стандарта писать 𝑳𝑶𝑹𝑲𝑰#0271

##### Discord

###### Сервер

ПБ Свободная Бухта: https://discord.gg/QpPDGBz8zc

###### Личные

Скрипты и сам стандарт: 𝑳𝑶𝑹𝑲𝑰#0271

Публичная сфера и тд: 𝕸𝖆𝖗𝖘𝖍𝖆𝖑𝖘𝖐𝖆 𝕽𝖔𝖐𝖔𝖘𝖘𝖔𝖛𝖘𝖐𝖞#8029

### Поддержка-разработчиков-Reflection-Team

DonatePay: https://new.donatepay.ru/@1073557
Карта MasterCard: 5167 9855 6211 0551
PAYYER: P5001254
DonationAlerts: https://www.donationalerts.com/r/reflectionproject
Boosty: https://boosty.to/lorki

**(ВРЕМЕННО НЕ РАБОТАЕТ)** Monero: 44sbNWtBVv83JenEDnQi4H7p5acgShGsW9zya3UDVPEQMiNmZfanPgu1Lvpct6MQAHNsspogWECqmHYhXwNAJBf5Fe3NPoR 

**(ВРЕМЕННО НЕ РАБОТАЕТ)** Bitcoin: В БУДУЩЕМ

##### Спасибо за вашу поддержку)